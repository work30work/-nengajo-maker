<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ğŸŒ¸ ä½œç”¨å¹´è³€çŠ¶è£½ä½œæ‰€ (V32 è£œä¸ç®¡ç†ç‰ˆ)</title>
  
  <link href="https://fonts.googleapis.com/css2?family=Hachi+Maru+Pop&family=Kaisei+Decol:wght@400;700&family=Ma+Shan+Zheng&family=Noto+Sans+TC:wght@400;500;700&family=Noto+Serif+TC:wght@500;700&family=Potta+One&family=Reggae+One&family=RocknRoll+One&family=Yuji+Syuku&family=Zen+Maru+Gothic:wght@500;700&display=swap" rel="stylesheet">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <style>
    :root {
      --primary: #d65a75;
      --secondary: #ffc6c7;
      --bg-color: #fdfcf8;
      --text-color: #4a4a4a;
      --card-shadow: 0 8px 20px rgba(0,0,0,0.15);
      --toolbar-bg: #fff0f3;
      --paper-color: #faf9f6;
    }

    body { 
      background-color: var(--bg-color); 
      color: var(--text-color);
      font-family: "Zen Maru Gothic", "Noto Sans TC", sans-serif; 
      margin: 0; padding: 20px 10px;
      text-align: center;
      overscroll-behavior: none;
    }
    
    h2 { 
      margin: 0 0 10px 0; color: var(--primary); 
      font-weight: 700; letter-spacing: 2px; 
      display: inline-block;
      border-bottom: 2px solid var(--secondary);
      padding-bottom: 5px;
      font-size: 1.2rem;
    }

    .app-container {
      display: flex; gap: 20px;
      max-width: 1200px; width: 100%;
      margin: 0 auto;
      align-items: flex-start; justify-content: center;
      flex-wrap: wrap; 
    }

    .canvas-section {
      flex: 0 0 auto;
      display: flex; flex-direction: column; gap: 0; align-items: center;
      width: 100%; max-width: 520px;
      position: relative;
    }
    
    .canvas-wrapper { 
      box-shadow: var(--card-shadow); 
      border: 1px solid #ddd;
      background-color: var(--paper-color); 
      max-width: 100%; 
      z-index: 10;
      position: relative;
    }

    .quick-toolbar {
      width: 100%;
      background: var(--toolbar-bg);
      padding: 8px; box-sizing: border-box;
      border-radius: 0 0 12px 12px;
      display: flex; flex-wrap: wrap; justify-content: space-between; gap: 5px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.05);
      margin-bottom: 15px;
      border: 1px solid #ffdde5; border-top: none;
    }
    .quick-group { display: flex; gap: 5px; align-items: center; }

    .btn-icon {
      padding: 8px 10px; font-size: 16px;
      background: white; border: 1px solid #ecc;
      border-radius: 6px; cursor: pointer; color: #666;
    }
    .btn-icon:hover { background: #fff5f7; color: var(--primary); }
    .btn-icon:disabled { opacity: 0.3; cursor: default; }
    .btn-trash { color: #e53935; border-color: #ffcdd2; }
    
    .tools-section {
      flex: 1; min-width: 300px; max-width: 450px;
      display: flex; flex-direction: column; gap: 15px;
      text-align: left;
    }

    .tool-card {
      background: white; padding: 15px; border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      transition: transform 0.2s;
    }
    
    .card-title {
      font-size: 14px; font-weight: 700; color: #888; margin: 0 0 10px 0;
      border-bottom: 1px solid #f0f0f0; padding-bottom: 5px;
      display: flex; justify-content: space-between; align-items: center;
    }

    button.normal-btn { 
      padding: 10px 12px; cursor: pointer;
      border: 1px solid #eee; background: white; 
      border-radius: 8px; font-size: 14px; color: #555;
      transition: 0.2s; font-family: inherit; font-weight: 500;
      white-space: nowrap; 
    }
    button.normal-btn.active { 
      background: var(--primary); color: white; border-color: var(--primary); 
    }

    .tool-row { display: flex; gap: 8px; margin-bottom: 8px; flex-wrap: wrap; align-items: center; }
    .full-width { width: 100%; display: flex; gap:5px; }
    .full-width button { flex: 1; }

    .category-tabs { display: flex; gap: 5px; margin-bottom: 10px; background: #f5f5f5; padding: 4px; border-radius: 8px; }
    .tab-btn {
      flex: 1; border: none; background: transparent; padding: 8px; font-size: 13px;
      border-radius: 6px; box-shadow: none; color: #666; cursor: pointer;
    }
    .tab-btn.active-tab {
      background: white; color: var(--primary); font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .sticker-grid { 
      display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); 
      gap: 8px; max-height: 250px; overflow-y: auto; padding: 5px;
      min-height: 100px;
    }
    .sticker-grid img { 
      width: 100%; aspect-ratio: 1; object-fit: contain; 
      border: 1px solid #f0f0f0; border-radius: 8px; 
      background: #fff; cursor: pointer;
    }

    .switch-label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px; }
    input[type="checkbox"] { accent-color: var(--primary); width: 16px; height: 16px; }

    .color-picker-wrapper {
      position: relative; overflow: hidden; width: 36px; height: 36px; border-radius: 50%;
      border: 2px solid #fff; box-shadow: 0 0 0 1px #ddd; cursor: pointer; flex-shrink: 0;
    }
    input[type="color"] {
      position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
      padding: 0; border: none; cursor: pointer;
    }
    select { padding: 8px; border: 1px solid #ccc; border-radius: 6px; background: white; font-size: 14px; min-width: 100px; }

    #render-hint {
      display:none; color: #d65a75; font-size: 12px; margin-top: 5px; font-weight: bold;
      animation: blink 2s infinite;
    }
    @keyframes blink { 0% {opacity: 1;} 50% {opacity: 0.5;} 100% {opacity: 1;} }

    #status-msg { 
      position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
      background: rgba(74, 74, 74, 0.95); color: white; 
      padding: 10px 24px; border-radius: 30px; 
      font-size: 13px; letter-spacing: 1px;
      opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 2000;
    }

    @media (max-width: 600px) {
      .app-container { gap: 15px; }
      .tools-section { width: 100%; min-width: auto; }
      .btn-icon { padding: 8px 12px; font-size: 14px; }
      .quick-toolbar { justify-content: center; gap: 10px; }
    }
  </style>
</head>
<body>

  <h2>ğŸŒ¸ ä½œç”¨å¹´è³€çŠ¶è£½ä½œæ‰€ (V32)</h2>

  <div class="app-container">
    
    <div class="canvas-section">
      <div class="canvas-wrapper" id="canvas-wrapper">
        <canvas id="c"></canvas>
      </div>

      <div class="quick-toolbar">
        <div class="quick-group">
          <button onclick="undo()" id="btn-undo" class="btn-icon" title="å¾©åŸ">â†©ï¸</button>
          <button onclick="redo()" id="btn-redo" class="btn-icon" title="é‡åš">â†ªï¸</button>
        </div>
        <div class="quick-group">
          <button onclick="deleteObject()" class="btn-icon btn-trash" title="åˆªé™¤é¸å–">ğŸ—‘ï¸</button>
        </div>
        <div class="quick-group">
          <button onclick="moveLayer('front')" class="btn-icon" title="ç½®é ‚">ğŸ”</button>
          <button onclick="moveLayer('up')" class="btn-icon" title="ä¸Šç§»">â¬†ï¸</button>
          <button onclick="moveLayer('down')" class="btn-icon" title="ä¸‹ç§»">â¬‡ï¸</button>
          <button onclick="moveLayer('back')" class="btn-icon" title="ç½®åº•">BOTTOM</button>
        </div>
      </div>
      
      <div class="full-width" style="margin-top:5px;">
        <button onclick="clearCanvas()" class="normal-btn" style="flex:1; font-size:12px; border:none; background:none; text-decoration:underline;">å…¨éƒ¨é‡ä¾†</button>
        <button onclick="downloadImage()" class="normal-btn" style="flex:2; background: #4CAF50; color: white; border: none; box-shadow: 0 4px 10px rgba(76, 175, 80, 0.3);">ğŸ’¾ ä¿å­˜å¡ç‰‡</button>
      </div>
    </div>

    <div class="tools-section">

      <div class="tool-card">
        <div class="card-title">æ“ä½œæ¨¡å¼</div>
        <div class="full-width">
          <button onclick="setMode('select')" id="btn-select" class="normal-btn active">âœ‹ èª¿æ•´</button>
          <button onclick="setMode('draw')" id="btn-draw" class="normal-btn">ğŸ–Œï¸ å¡—é´‰</button>
          <button onclick="setMode('eraser')" id="btn-eraser" class="normal-btn">â¬œ ç«‹å¯ç™½</button>
          <button onclick="setMode('patch')" id="btn-patch" class="normal-btn" style="color: #673ab7; border-color: #d1c4e9; background: #ede7f6;">ğŸ©¹ è£œä¸</button>
        </div>
        
        <div id="brush-controls" style="margin-top: 15px; display: none; background: #f9f9f9; padding: 10px; border-radius: 8px;">
          <div id="brush-settings-group">
            <div id="brush-type-row" class="tool-row">
              <div class="color-picker-wrapper" title="ç­†åˆ·é¡è‰²">
                <input type="color" id="brush-color" value="#000000" onchange="updateBrush()">
              </div>
              <select id="brush-type" onchange="updateBrush()" style="flex:1;">
                <option value="calligraphy">âœ’ï¸ æ¸²æŸ“æ¯›ç­† (Ink)</option>
                <option value="crayon">ğŸ–ï¸ è Ÿç­† (Crayon)</option>
                <option value="pencil">âœï¸ é‰›ç­† (Pencil)</option>
                <option value="marker">ğŸ–Šï¸ è¢å…‰ç­† (Marker)</option>
                <option value="spray">ğŸ’¨ å™´æ§ (Spray)</option>
              </select>
            </div>
            <div class="tool-row">
              <span style="font-size:12px;">ç²—ç´°</span>
              <input type="range" id="brush-width" min="1" max="100" value="20" onchange="updateBrush()" style="flex:1;">
            </div>
            <div id="render-hint">ğŸ–Œï¸ æ¯›ç­†/è Ÿç­†é‹ç®—è¼ƒè¤‡é›œï¼Œè«‹æ”¾æ‰‹å¾Œç¨ç­‰æ¸²æŸ“</div>
            <div id="eraser-restore-area" style="display:none;">
               <button onclick="cleanEraserMarks()" class="btn-restore">âœ¨ åˆ®é™¤æ‰€æœ‰ç«‹å¯ç™½</button>
            </div>
          </div>

          <div id="patch-settings-area" style="display:none;">
            <p style="color:#673ab7; font-size:12px; font-weight:bold; margin-bottom:5px;">
              ğŸ©¹ è£œä¸æ¨¡å¼ (é è¨­é–å®šï¼Œé˜²æ­¢èª¤è§¸)
            </p>
            <label class="switch-label" style="background:#e3f2fd; padding:8px; border-radius:6px; color:#1565c0; font-weight:bold;">
              <input type="checkbox" id="patch-edit-toggle" onchange="togglePatchEditMode()"> 
              ğŸ”“ é¸å–/åˆªé™¤è£œä¸ (å‹¾é¸å¾Œå¯é¸å–)
            </label>
          </div>
        </div>
      </div>

      <div class="tool-card">
        <div class="card-title">
          <span>ğŸ“¦ é›²ç«¯ç´ æ</span>
          <label class="switch-label">
            <input type="checkbox" id="bg-mode-toggle"> 
            <span style="color:var(--primary); font-weight:bold;">è¨­ç‚ºèƒŒæ™¯</span>
          </label>
        </div>
        <div class="category-tabs">
          <button class="tab-btn active-tab" onclick="switchCategory('stickers', this)">ğŸ¶ è²¼åœ–</button>
          <button class="tab-btn" onclick="switchCategory('backgrounds', this)">ğŸ–¼ï¸ èƒŒæ™¯</button>
        </div>
        <div id="sticker-list" class="sticker-grid">
          <p style="font-size:12px; color:#999; padding:10px;">è®€å–ä¸­...</p>
        </div>
        <div style="margin-top:10px; border-top:1px dashed #eee; padding-top:10px;">
           <label style="display:flex; align-items:center; gap:5px; justify-content:center; cursor:pointer; color:#888; font-size:12px;">
             ğŸ“‚ ä¸Šå‚³åœ–ç‰‡
             <input type="file" style="display:none" accept="image/*" onchange="handleUniversalUpload(this)">
           </label>
        </div>
      </div>

      <div class="tool-card">
        <div class="card-title">æ–‡å­—å·¥å…·</div>
        <div class="tool-row">
          <input type="text" id="text-input" placeholder="è¼¸å…¥è³€è©..." value="æ–°å¹´å¿«æ¨‚" style="flex:1; padding:8px; border:1px solid #ccc; border-radius:4px;">
          <div class="color-picker-wrapper" title="æ–‡å­—é¡è‰²">
            <input type="color" id="text-color" value="#d65a75">
          </div>
        </div>
        <div class="tool-row">
          <select id="font-select" style="flex:2;">
            <optgroup label="æ›¸æ³•æ‰‹å¯«é¡">
              <option value="Ma Shan Zheng">æ›¸æ³•æ‰‹å¯«é«”</option>
              <option value="Yuji Syuku">æ—¥å¼è¡Œæ›¸</option>
              <option value="Potta One">èƒ–èƒ–æ¯›ç­†é«”</option>
            </optgroup>
            <optgroup label="å¯æ„›åœ“é«”é¡">
              <option value="Hachi Maru Pop">æ³¢æ³¢é«”</option>
              <option value="Zen Maru Gothic">æ—¥ç³»åœ“é«”</option>
              <option value="RocknRoll One">æ–æ»¾åœ“é«”</option>
            </optgroup>
            <optgroup label="æ¨™æº–/è¥¯ç·šé¡">
              <option value="Noto Sans TC">æ¨™æº–é»‘é«”</option>
              <option value="Noto Serif TC">æ¨™æº–æ˜é«”</option>
              <option value="Kaisei Decol">å„ªé›…è¥¯ç·šé«”</option>
              <option value="Reggae One">å‰›å‹é«”</option>
            </optgroup>
          </select>
          <button onclick="toggleVertical()" id="btn-vertical" style="flex:1;" class="normal-btn">â¡ï¸ æ©«æ›¸</button>
        </div>
        <button onclick="addText()" class="normal-btn" style="width:100%; background:#f0f0f0;">â• åŠ å…¥æ–‡å­—</button>
      </div>

    </div>
  </div>

  <div id="status-msg">æ“ä½œæˆåŠŸ</div>

  <script>
    // âš ï¸âš ï¸âš ï¸ è«‹åœ¨é€™è£¡å¡«å…¥æ‚¨çš„ Supabase è³‡æ–™ âš ï¸âš ï¸âš ï¸
    const SUPABASE_URL = 'https://kyjppevleohxkrxvghve.supabase.co'; 
    const SUPABASE_KEY = 'sb_publishable_ICm0LIiw6DHBz-s7SHUYuQ_kDqSlITB';

    const screenWidth = window.innerWidth;
    const maxCanvasWidth = 500;
    const canvasWidth = Math.min(maxCanvasWidth, screenWidth - 25);
    const canvasHeight = canvasWidth * 1.48; 

    const canvas = new fabric.Canvas('c', {
      width: canvasWidth,
      height: canvasHeight,
      backgroundColor: '#faf9f6', 
      isDrawingMode: false,
      preserveObjectStacking: true,
      selection: true 
    });

    let currentBgUrl = '';
    let isVertical = false;
    let history = [];
    let historyRedo = [];
    let isHistoryProcessing = false;
    let currentCategory = 'stickers';
    
    let patchMode = false;
    let patchEditMode = false; // V32: æ§åˆ¶æ˜¯å¦å¯é¸å–è£œä¸
    let patchRect = null;
    let patchStartX = 0;
    let patchStartY = 0;

    function saveState() {
      if (isHistoryProcessing) return;
      const currentState = JSON.stringify(canvas.toDatalessJSON(['isBackground', 'isPatch'])); 
      if (history.length > 0 && history[history.length - 1] === currentState) return;
      if (history.length > 30) history.shift();
      history.push(currentState);
      historyRedo = [];
      updateHistoryButtons();
    }
    
    function restoreLocks() { 
      canvas.getObjects().forEach(obj => {
        if (obj.isBackground) {
          obj.set({
            selectable: false, evented: false, hasControls: false,
            hasBorders: false, lockMovementX: true, lockMovementY: true
          });
          canvas.sendToBack(obj);
        }
      });
      canvas.requestRenderAll(); 
    }

    // çµ±ä¸€ç®¡ç†ç‰©ä»¶ç‹€æ…‹ (åŒ…å«è£œä¸)
    function updateObjectSelectability() {
      canvas.getObjects().forEach(obj => {
        if (obj.isBackground) return; 

        if (patchMode) {
          // V32: å¦‚æœåœ¨è£œä¸æ¨¡å¼
          if (patchEditMode) {
             // ç·¨è¼¯æ¨¡å¼ï¼šåªå…è¨±é¸å–è£œä¸ï¼Œå…¶ä»–è²¼åœ–ä¸çµ¦å‹• (é¿å…å¹²æ“¾)
             if (obj.isPatch) obj.set({ selectable: true, evented: true });
             else obj.set({ selectable: false, evented: false });
          } else {
             // ç•«åœ–æ¨¡å¼ï¼šå…¨é–ï¼Œåªå…è¨±ç•«æ¡†
             obj.set({ selectable: false, evented: false });
          }
        } else {
          // å…¶ä»–æ¨¡å¼ï¼šè£œä¸é–æ­»ï¼Œå…¶ä»–å¯å‹•
          if (obj.isPatch) obj.set({ selectable: false, evented: false });
          else obj.set({ selectable: true, evented: true });
        }
      });
      canvas.requestRenderAll();
    }

    canvas.on('object:added', (e) => { 
        if(!isHistoryProcessing && !patchMode) saveState(); 
        updateObjectSelectability(); 
    });
    canvas.on('object:modified', saveState);
    canvas.on('object:removed', saveState);
    canvas.on('path:created', saveState);

    // V32: åˆ‡æ›è£œä¸ç·¨è¼¯ç‹€æ…‹
    function togglePatchEditMode() {
      patchEditMode = document.getElementById('patch-edit-toggle').checked;
      
      // å¦‚æœé€²å…¥ç·¨è¼¯æ¨¡å¼ï¼Œè¦å–æ¶ˆç•¶å‰çš„é¸å–(å¦‚æœæœ‰)ï¼Œä¸¦é‡æ–°è¨­å®šå¯é¸å–æ€§
      canvas.discardActiveObject();
      updateObjectSelectability();
      
      if(patchEditMode) showStatus('ğŸ”“ ç¾åœ¨å¯ä»¥é»é¸è£œä¸é€²è¡Œåˆªé™¤');
      else showStatus('ğŸ”’ è£œä¸å·²é–å®šï¼Œå¯ä»¥ç¹¼çºŒç•«æ–°è£œä¸');
    }

    // è£œä¸æ‹–æ›³é‚è¼¯
    canvas.on('mouse:down', function(opt) {
        if (!patchMode || patchEditMode) return; // ç·¨è¼¯æ¨¡å¼ä¸‹ä¸ç•«æ¡†
        
        const pointer = canvas.getPointer(opt.e);
        patchStartX = pointer.x;
        patchStartY = pointer.y;

        patchRect = new fabric.Rect({
            left: patchStartX, top: patchStartY,
            width: 0, height: 0,
            fill: 'rgba(103, 58, 183, 0.2)', 
            stroke: '#673ab7',
            strokeWidth: 2,
            strokeDashArray: [5, 5],
            selectable: false, evented: false
        });
        canvas.add(patchRect);
    });

    canvas.on('mouse:move', function(opt) {
        if (!patchMode || patchEditMode || !patchRect) return;
        const pointer = canvas.getPointer(opt.e);
        if (pointer.x < patchStartX) patchRect.set({ left: pointer.x });
        if (pointer.y < patchStartY) patchRect.set({ top: pointer.y });
        patchRect.set({
            width: Math.abs(pointer.x - patchStartX),
            height: Math.abs(pointer.y - patchStartY)
        });
        canvas.requestRenderAll();
    });

    canvas.on('mouse:up', function() {
        if (!patchMode || patchEditMode || !patchRect) return;
        const cropLeft = patchRect.left;
        const cropTop = patchRect.top;
        const cropWidth = patchRect.width;
        const cropHeight = patchRect.height;
        canvas.remove(patchRect);
        patchRect = null;
        if (cropWidth < 5 || cropHeight < 5) return; 
        createPatch(cropLeft, cropTop, cropWidth, cropHeight);
    });

    function createPatch(left, top, width, height) {
        const bgObj = canvas.getObjects().find(o => o.isBackground);
        if (!bgObj) {
            showStatus('âš ï¸ è«‹å…ˆè¨­å®šèƒŒæ™¯åœ–æ‰èƒ½ä½¿ç”¨è£œä¸');
            return;
        }
        const otherObjects = canvas.getObjects().filter(o => o !== bgObj);
        otherObjects.forEach(o => o.opacity = 0); 
        
        const dataURL = canvas.toDataURL({
            left: left, top: top, width: width, height: height,
            format: 'png', multiplier: 1
        });

        otherObjects.forEach(o => o.opacity = 1);

        fabric.Image.fromURL(dataURL, function(img) {
            img.set({
                left: left, top: top,
                selectable: false, 
                evented: false,
                isPatch: true
            });
            canvas.add(img);
            saveState();
            showStatus('âœ… è£œä¸å·²è²¼ä¸Š');
        });
    }

    function undo() {
      if (history.length <= 1) return;
      isHistoryProcessing = true;
      historyRedo.push(history.pop());
      const content = history[history.length - 1];
      canvas.loadFromJSON(content, () => {
        restoreLocks();
        updateObjectSelectability();
        isHistoryProcessing = false;
        updateHistoryButtons();
        showStatus('å·²å¾©åŸ');
      });
    }

    function redo() {
      if (historyRedo.length === 0) return;
      isHistoryProcessing = true;
      const content = historyRedo.pop();
      history.push(content);
      canvas.loadFromJSON(content, () => {
        restoreLocks();
        updateObjectSelectability();
        isHistoryProcessing = false;
        updateHistoryButtons();
        showStatus('å·²é‡åš');
      });
    }

    function updateHistoryButtons() {
      const undoBtn = document.getElementById('btn-undo');
      const redoBtn = document.getElementById('btn-redo');
      if(undoBtn) undoBtn.disabled = (history.length <= 1);
      if(redoBtn) redoBtn.disabled = (historyRedo.length === 0);
    }

    function cleanEraserMarks() {
      const objects = canvas.getObjects();
      let removedCount = 0;
      for (let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        if (obj.type === 'path' && obj.stroke === '#faf9f6') {
          canvas.remove(obj);
          removedCount++;
        }
      }
      restoreLocks();
      saveState();
      if (removedCount > 0) showStatus(`ğŸ§¹ å·²åˆ®é™¤ ${removedCount} ç­†ç«‹å¯ç™½`);
      else showStatus('ç›®å‰æ²’æœ‰ç«‹å¯ç™½ç—•è·¡');
    }

    // V32: æ›´æ–°åˆªé™¤é‚è¼¯ï¼Œå…è¨±åˆªé™¤è£œä¸ (ç•¶è™•æ–¼å¯é¸ç‹€æ…‹æ™‚)
    function deleteObject() {
      const active = canvas.getActiveObject();
      if (!active) return showStatus('è«‹å…ˆé»é¸ç‰©ä»¶');
      
      // èƒŒæ™¯æ°¸é ä¸èƒ½åˆª
      if (active.isBackground) return showStatus('èƒŒæ™¯ç„¡æ³•åˆªé™¤');
      
      // è£œä¸ï¼šå¿…é ˆåœ¨ç·¨è¼¯æ¨¡å¼ä¸‹æ‰èƒ½åˆª (ç†è«–ä¸Šå¦‚æœèƒ½é¸åˆ°å°±æ˜¯å¯åˆªï¼Œä½†é›™é‡ä¿éšª)
      if (active.isPatch && !patchEditMode) return showStatus('è£œä¸å·²é–å®š');

      canvas.remove(active);
      saveState();
      showStatus('å·²åˆªé™¤');
    }

    function setMode(mode) {
      document.getElementById('btn-select').className = (mode === 'select' ? 'normal-btn active' : 'normal-btn');
      document.getElementById('btn-draw').className = (mode === 'draw' ? 'normal-btn active' : 'normal-btn');
      document.getElementById('btn-eraser').className = (mode === 'eraser' ? 'normal-btn active' : 'normal-btn');
      document.getElementById('btn-patch').className = (mode === 'patch' ? 'normal-btn active' : 'normal-btn');

      const controls = document.getElementById('brush-controls');
      const brushSettings = document.getElementById('brush-settings-group');
      const eraserRestore = document.getElementById('eraser-restore-area');
      const patchSettings = document.getElementById('patch-settings-area');

      // é‡ç½®ç‹€æ…‹
      patchMode = false;
      canvas.isDrawingMode = false;
      canvas.selection = true; 
      
      // åˆ‡æ›æ¨¡å¼æ™‚ï¼Œé è¨­æŠŠè£œä¸ç·¨è¼¯é—œæ‰ (å›åˆ°å®‰å…¨ç‹€æ…‹)
      document.getElementById('patch-edit-toggle').checked = false;
      patchEditMode = false;

      if (mode === 'select') {
        controls.style.display = 'none';
      } 
      else if (mode === 'draw') {
        canvas.isDrawingMode = true;
        controls.style.display = 'block';
        brushSettings.style.display = 'block';
        eraserRestore.style.display = 'none';
        patchSettings.style.display = 'none';
        
        document.getElementById('brush-type-row').style.display = 'flex';
        if(canvas.freeDrawingBrush) canvas.freeDrawingBrush.globalCompositeOperation = 'source-over';
        updateBrush(); 
      } 
      else if (mode === 'eraser') {
        canvas.isDrawingMode = true;
        controls.style.display = 'block';
        brushSettings.style.display = 'block';
        eraserRestore.style.display = 'block';
        patchSettings.style.display = 'none';
        
        document.getElementById('brush-type-row').style.display = 'none';

        const width = parseInt(document.getElementById('brush-width').value, 10);
        const brush = new fabric.PencilBrush(canvas);
        brush.width = width; 
        brush.color = "#faf9f6"; 
        brush.shadow = null;
        canvas.freeDrawingBrush = brush;
        canvas.freeDrawingBrush.globalCompositeOperation = 'source-over';
      }
      else if (mode === 'patch') {
        patchMode = true;
        canvas.selection = false; 
        
        controls.style.display = 'block';
        brushSettings.style.display = 'none'; 
        patchSettings.style.display = 'block';
      }
      
      updateObjectSelectability();
    }

    function updateBrush() {
      if (document.getElementById('btn-eraser').classList.contains('active')) return;
      if (patchMode || !canvas.isDrawingMode) return; 

      const type = document.getElementById('brush-type').value;
      const color = document.getElementById('brush-color').value;
      const width = parseInt(document.getElementById('brush-width').value, 10);
      const hint = document.getElementById('render-hint');

      let brush;
      let showHint = false;
      
      if(canvas.freeDrawingBrush) canvas.freeDrawingBrush.globalCompositeOperation = 'source-over';

      if (type === 'calligraphy') {
        brush = new fabric.SprayBrush(canvas);
        brush.width = width * 1.5;
        brush.density = 80;  
        brush.dotWidth = 1.5;
        brush.dotWidthVariance = 2.5; 
        brush.randomOpacity = true; 
        const c = new fabric.Color(color);
        c.setAlpha(0.5); 
        brush.color = c.toRgba();
        showHint = true;

      } else if (type === 'crayon') {
        brush = new fabric.SprayBrush(canvas);
        brush.width = width * 1.5;
        brush.density = 50; 
        brush.dotWidth = 1;
        brush.dotWidthVariance = 1;
        brush.randomOpacity = true;
        brush.color = color;
        showHint = true;

      } else if (type === 'spray') {
        brush = new fabric.SprayBrush(canvas);
        brush.width = width * 2;
        brush.density = 20; 
        brush.color = color;

      } else if (type === 'marker') {
        brush = new fabric.PencilBrush(canvas);
        const c = new fabric.Color(color);
        c.setAlpha(0.3);
        brush.color = c.toRgba();
        brush.width = width * 3;
        brush.shadow = null;

      } else {
        brush = new fabric.PencilBrush(canvas);
        brush.width = width;
        brush.color = color;
        brush.shadow = null;
      }

      canvas.freeDrawingBrush = brush;
      hint.style.display = showHint ? 'block' : 'none';
    }

    async function switchCategory(category, btn) {
      currentCategory = category;
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active-tab'));
      btn.classList.add('active-tab');
      const bgToggle = document.getElementById('bg-mode-toggle');
      bgToggle.checked = (category === 'backgrounds');
      loadCloudImages(category);
    }

    async function loadCloudImages(folder) {
      const listDiv = document.getElementById('sticker-list');
      if (SUPABASE_URL.includes('xxxx')) {
        listDiv.innerHTML = '<p style="color:#d65a75; font-size:12px;">âš ï¸ è«‹å¡« Key</p>';
        return;
      }
      listDiv.innerHTML = '<p style="font-size:12px; color:#999; padding:5px;">è®€å–ä¸­...</p>';
      try {
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        const { data, error } = await supabase.storage.from('assets').list(folder);
        if (error) throw error;
        listDiv.innerHTML = '';
        if (data && data.length > 0) {
          const items = data.filter(i => i.name !== '.emptyFolderPlaceholder');
          if (items.length === 0) {
             listDiv.innerHTML = `<p style="font-size:12px; padding:10px;">è³‡æ–™å¤¾ ${folder} æ˜¯ç©ºçš„</p>`;
             return;
          }
          items.forEach(item => {
            const url = supabase.storage.from('assets').getPublicUrl(folder + '/' + item.name).data.publicUrl;
            const img = document.createElement('img');
            img.src = url;
            img.onclick = () => { processImage(url, false); };
            listDiv.appendChild(img);
          });
        } else {
          listDiv.innerHTML = `<p style="font-size:12px; padding:10px;">è³‡æ–™å¤¾ç‚ºç©º</p>`;
        }
      } catch (err) {
        console.error(err);
        listDiv.innerHTML = '<p style="color:red; font-size:12px;">è®€å–å¤±æ•—</p>';
      }
    }

    function processImage(source, isFile) {
      const isBgMode = document.getElementById('bg-mode-toggle').checked;
      
      const handleImg = (imgUrl) => {
           fabric.Image.fromURL(imgUrl, (img) => {
              if (isBgMode) {
                const scale = Math.max(canvas.width / img.width, canvas.height / img.height);
                img.set({
                  left: canvas.width / 2, top: canvas.height / 2,
                  originX: 'center', originY: 'center',
                  scaleX: scale, scaleY: scale,
                  selectable: false, evented: false, hasControls: false,
                  hasBorders: false, lockMovementX: true, lockMovementY: true,
                  isBackground: true 
                });
                canvas.add(img);
                canvas.sendToBack(img);
                canvas.requestRenderAll();
                showStatus('ğŸ–¼ï¸ èƒŒæ™¯å·²è¨­å®š');
              } else {
                const targetWidth = canvas.width * 0.4; 
                img.scaleToWidth(targetWidth);
                img.set({left: canvas.width/2 - targetWidth/2, top: 150});
                canvas.add(img);
                canvas.setActiveObject(img);
                showStatus('âœ… åœ–ç‰‡å·²åŠ å…¥');
                setMode('select');
              }
           }, { crossOrigin: 'anonymous' });
      };

      if(isFile) {
          const reader = new FileReader();
          reader.onload = function(f) { handleImg(f.target.result); };
          reader.readAsDataURL(source);
      } else {
          handleImg(source);
      }
    }

    function handleUniversalUpload(input) {
      const file = input.files[0];
      if (!file) return;
      processImage(file, true);
      input.value = '';
    }

    function addText() {
      const textVal = document.getElementById('text-input').value;
      const fontVal = document.getElementById('font-select').value;
      const colorVal = document.getElementById('text-color').value;
      const finalVal = isVertical ? textVal.split('').join('\n') : textVal;
      const text = new fabric.IText(finalVal, {
        left: 50, top: 100, fontSize: 40,
        fontFamily: fontVal, fill: colorVal,
        textAlign: isVertical ? 'center' : 'left',
        lineHeight: isVertical ? 0.85 : 1.2
      });
      canvas.add(text);
      canvas.setActiveObject(text);
      setMode('select');
    }

    function toggleVertical() {
      isVertical = !isVertical;
      const btn = document.getElementById('btn-vertical');
      btn.textContent = isVertical ? 'â¬‡ï¸ ç›´æ›¸' : 'â¡ï¸ æ©«æ›¸';
    }

    function moveLayer(dir) {
      const active = canvas.getActiveObject();
      if (!active) return showStatus('è«‹å…ˆé¸å–ç‰©ä»¶');
      if (active.selectable === false || active.isBackground || active.isPatch) return showStatus('èƒŒæ™¯èˆ‡è£œä¸ä¸èƒ½ç§»å‹•');

      if (dir === 'front') active.bringToFront();
      if (dir === 'back') active.sendToBack();
      if (dir === 'up') active.bringForward();
      if (dir === 'down') active.sendBackwards();
      canvas.requestRenderAll(); 
      saveState();
    }

    function deleteObject() {
      const active = canvas.getActiveObject();
      if (!active) return showStatus('è«‹å…ˆé»é¸ç‰©ä»¶');
      
      // V32: åˆªé™¤æ¢ä»¶æ›´æ–°
      if (active.isBackground) return showStatus('èƒŒæ™¯ç„¡æ³•åˆªé™¤');
      // å¦‚æœæ˜¯è£œä¸ï¼Œä¸”ä¸åœ¨ç·¨è¼¯æ¨¡å¼ï¼Œç¦æ­¢åˆªé™¤
      if (active.isPatch && !patchEditMode) return showStatus('è£œä¸å·²é–å®š (è«‹å‹¾é¸è§£é–)');

      canvas.remove(active);
      saveState();
      showStatus('å·²åˆªé™¤');
    }

    function showStatus(msg) {
      const el = document.getElementById('status-msg');
      el.textContent = msg;
      el.style.opacity = 1;
      setTimeout(() => el.style.opacity = 0, 2000);
    }
    
    function clearCanvas() {
      if(confirm('ç¢ºå®šè¦æ¸…ç©ºå¡—é´‰å—ï¼Ÿ')) { 
        canvas.clear(); 
        canvas.setBackgroundColor('#faf9f6', canvas.renderAll.bind(canvas));
        history = []; saveState();
      }
    }

    function downloadImage() {
      const link = document.createElement('a');
      link.download = 'nengajo.png';
      link.href = canvas.toDataURL({format:'png', quality:1});
      link.click();
    }

    loadCloudImages('stickers');
  </script>
</body>
</html>
